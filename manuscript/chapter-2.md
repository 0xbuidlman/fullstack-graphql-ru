# 2. Моделирование данных

В предыдущей главе вы узнали, как читать и записывать данные, отправляя запросы к схеме с использованием языка запросов GraphQL. В этой главе вы научитесь, как моделировать данные, лежащие в основе запросов, используя схемы и типы. Для создания такой схемы, вы будете использовать язык определения схемы (Schema Definition Language) GraphQL (также называемый SDL, чтобы не путать с LSD).

В то время как предыдущая глава была посвящена взаимодействию клиентов с серверами, используя GraphQL, в этой главе будет рассказано, как представить модель данных, которую могут использовать клиенты.

Помните клон Pinterest, о котором шла речь во введении? Изучив концепции схем и типов GraphQL, к концу главы вы разработаете модель данных.

## 2.1 Схема, типы и резолверы

Серверы GraphQL предоставляют свою схему для того, чтобы клиенты знали, какие доступны запросы и мутации. Для определения того, как выглядит схема, вам нужно объявить типы всех полей. Чтобы определить, как ведет себя схема, вам нужно создать функцию, которую сервер будет запускать, когда клиент запрашивает поле, — такая функция называется резолвером. Схема нуждается как в определениях типов, так и в резолверах.

![Типы и резолверы](images/types-resolvers.png)

Поскольку GraphQL — это спецификация, реализованная на многих языках программирования, она предоставляет собственный язык для разработки схем, называемый SDL. Вы пишете определения типов на SDL, хотя создавать резолверы можно на любом языке, который реализует спецификацию GraphQL. Эта книга посвящена Javascript-экосистеме GraphQL, поэтому вам предстоит все резолверы на данном языке.

Схема, которую вы создадите, — это нечто большее, чем просто пример, иллюстрирующий, как писать SDL-код. Это первый шаг к разработке PinApp, пример приложения данной книги. Создаваемая схема будет отражать большинство возможностей в готовом приложении:

* Авторизация с помощью магических ссылок
* Возможность аутентифицированным  пользователям добавлять пины
* Поиск по пинам и пользователям
* Список пинов

Создайте собственную копию этого примера с помощью следующей ссылки:

[Клонировать пример схемы](https://glitch.com/edit/#!/remix/pinapp-schema)

> После клонирования внимательно следуйте инструкциям в `README.md`. Файл README этого проекта сообщает вам создать переменные окружения в специальном для этого файле `.env`.

Имейте в виду, что эта схема не распространяется через протокол HTTP. Она доступна со скриптами, использующими `graphql-js`. Следующая глава покажет вам, как добавить HTTP-слой в эту схему с помощью Apollo Server.

В следующем разделе вы поймете, как создавать схемы, используя функцию `makeExecutableSchema`.

## 2.2 Схемы

Создание схемы происходит путём сочетания определений типов и резолверов. Существует удобный пакет [`graphql-tools`](https://github.com/apollographql/graphql-tools), предоставляющий функцию `makeExecutableSchema`. Предыдущая глава содержала много вызовов `graphql(query, schema)`. Все существующие примеры отправляют запросы согласно схемы, сгенерированной с помощью функции `makeExecutableSchema`.

Откройте файл `schema.js` в примере проекта, который вы только что склонировали, чтобы узнать, как можно создать схему.

```js
const { makeExecutableSchema } = require("graphql-tools");
const { importSchema } = require("graphql-import");

const typeDefs = importSchema("schema.graphql");
const resolvers = require("./resolvers");

const schema = makeExecutableSchema({
  typeDefs,
  resolvers
});

module.exports = schema;
```

Как видите, этот файл создает схему с типами из файла `schema.graphql` и резолверами из файла `resolvers.js`. В следующих двух разделах вы научитесь, как создавать определения типов и резолверы.

## 2.3 Определения типов

В этом разделе вы научитесь тому, как писать типы GraphQL, используя SDL. Тип — это просто представление объекта в вашей схеме. Объекты, как и во многих других языках программирования, могут иметь много полей.

> Все примеры в этом разделе можно найти в файле `schema.graphql`

Определить тип объекта можно подобным образом:

```graphql
type Pin {
  title: String!
  link: String!
  image: String!
  id: String!
  user_id: String!
}
```

Как видно, можно определить тип полей после имени поля. В случае `Pin`, у всех его полей указан тип `String` и все они являются обязательными, поскольку заканчиваются восклицательным знаком (!).

GraphQL определяет два специальных типа объектов — `Query` и `Mutation`. Они особенные, потому что они определяют точки входа в схему. Быть точкой входа в схему означает, что клиенты GraphQL должны начинать свои запросы с одного или нескольких полей из `Query`.

```graphql
type Query {
  pins: [Pin]
  pinById(id: String!): Pin
  users: [User]
  me: User
  search(text: String): [SearchResult]
}
```

Как вы, наверное, заметили, у типов объектов могут быть аргументы. Каждое поле имеет базовую функцию (называемую резолвером), которая выполняется перед возвратом собственного значения, поэтому имеет смысл рассматривать аргументы поля по аналогии с тем, как мы размышляем над аргументами функции.

Еще один новый элемент в предыдущем `Query` — это модификатор типа List. Возможно заключить поля в квадратные скобки, чтобы указать их как списки.

Спецификация GraphQL определяет, что все схемы должны иметь тип `Query`, а также необязательно тип `Mutation`. Вот так выглядит тип `Mutation` в PinApp:

```graphql
type Mutation {
  addPin(pin: PinInput!): Pin
  sendShortLivedToken(email: String!): Boolean
  createLongLivedToken(token: String!): String
}
```

Обратите внимание, что поле `addPin` имеет аргумент `pin` с указанным типом `PinInput`, а у двух остальных полей есть аргументы типа `String`. Вы не можете передавать аргументы типа `Object` в качестве аргументов, разрешено передавать только скалярные типы, а также типы `Input`.

Скалярные типы не могут иметь вложенные поля, они представляют собой листья[^leaves] схемы. Это встроенные скалярные типы в GraphQL:
[^leaves]: Элементы самого нижнего уровня в древовидном представлении иерархии

* `Int`
* `Float`
* `String`
* `Boolean`
* `ID`

Некоторые реализации GraphQL позволяют определять пользовательские скалярные типы. Это означает, что есть возможность создавать собственные скаляры, такие как `Date` или `JSON`.

Вы можете определить специальный вид скаляров, используя перечислимые типы (`enum`). Перечисления — специальные скалярные типы, потому что они ограничены фиксированным набором значений.

Вот таким образом выглядит перечислимый тип:

```graphql
enum PinStatus {
  DELETED
  HIDDEN
  VISIBLE
}
```

Типы `Input` работает почти так же, как объекты. Внутри них могут быть поля, но разница в том, что такие поля не могут иметь аргументов и также тип `Object`.

Вот как определяется нестандартный тип `PinInput`:

```graphql
input PinInput {
  title: String!
  link: String!
  image: String!
}
```

GraphQL позволяет также определять типы `Interface` и `Union`. Они полезны, когда вам нужно вернуть объект, который может состоять из нескольких разных типов.

Можно воспользоваться интерфейсами, когда есть разные типы, имеющие общие поля между собой. Типичный случай использования будет представлять тип `User`.

```graphql
interface Person {
  id: String!
  email: String!
  pins: [Pin]
}

type User implements Person {
  id: String!
  email: String!
  pins: [Pin]
}

type Admin implements Person {
  id: String!
  email: String!
  pins: [Pin]
}
```

В случае, если вам нужен тип, который представляет разные типы без общих полей между собой, в вашем распоряжении есть тип `Union`. Типичная операция, которая возвращает такой тип, — это поиск:

```graphql
union SearchResult = User | Admin | Pin

type Query {
  # ...
  search(text: String): [SearchResult]
}
```

Вот как выглядит полная версия `schema.graphql`:

```graphql
type Pin {
  title: String!
  link: String!
  image: String!
  id: String!
  user_id: String!
}

input PinInput {
  title: String!
  link: String!
  image: String!
}

interface Person {
  id: String!
  email: String!
  pins: [Pin]
}

type User implements Person {
  id: String!
  email: String!
  pins: [Pin]
}

type Admin implements Person {
  id: String!
  email: String!
  pins: [Pin]
}

union SearchResult = User | Admin | Pin

type Query {
  pins: [Pin]
  pinById(id: String!): Pin
  users: [User]
  me: User
  search(text: String): [SearchResult]
}

type Mutation {
  addPin(pin: PinInput!): Pin
  sendShortLivedToken(email: String!): Boolean
  createLongLivedToken(token: String!): String
}
```

Как вы узнали из предыдущего раздела, схема состоит из определений типов и резолверов. И поскольку сейчас, когда вы знаете, как выглядят определения типов, пришло время узнать про резолверы.

## 2.4 Резолверы

Резолверы — это функции, которые запускаются каждый раз, когда запрос запрашивает поле. Когда реализация GraphQL получает запрос, она выполняет резолвер для каждого поля. Если резолвер возвращает поле типа `Object`, то GraphQL запускает резолвер-функцию этого поля. Когда все резолверы возвращают скалярные значения, цепочка замыкается, и запрос получает готовый JSON-результат.

Поскольку GraphQL не привязан к какой-либо технологии баз данных, поэтому реализация резолвера полностью зависит от вас. Все функции в файле `resolvers.js` используют обычный JS-объект, служащий базой данных в оперативной памяти, однако уже в следующей главе вы узнаете, как выполнить миграцию в базу данных Postgres.

Вы можете организовать резолверы любым способом, в зависимости от ваших потребностей. Примеры этой книги стремятся держать резолвер-функции простыми, а также разделить доступ к базе данных с помощью бизнес-логики. Это простой случай применения старого доброго принципа [разделения ответственности](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8).

Давайте посмотрим, как выглядит `resolvers.js`:

```js
const {
  addPin,
  createShortLivedToken,
  sendShortLivedToken,
  createLongLivedToken,
  createUser
} = require("./business-logic");

const database = {
  users: {},
  pins: {}
};

const resolvers = {
  Query: {
    pins: () => Object.values(database.pins),
    users: () => Object.values(database.users),
    search: (_, { text }) => {
      return [
        ...Object.values(database.pins).filter(pin =>
          pin.title.includes(text)
        ),
        ...Object.values(database.users).filter(user =>
          user.email.includes(text)
        )
      ];
    }
  },
  Mutation: {
    addPin: async (_, { pin }, { user }) => {
      const {
        user: updatedUser,
        pin: createdPin
      } = await addPin(user, pin);
      database.pins[createdPin.id] = createdPin;
      database.users[user.id] = updatedUser;
      return createdPin;
    },
    sendShortLivedToken: (_, { email }) => {
      let user;
      const userExists = Object.values(database.users).find(
        u => u.email === user.email
      );
      if (userExists) {
        user = userExists;
      } else {
        user = createUser(email);
        database.users[user.id] = user;
      }
      const token = createShortLivedToken(user);
      return sendShortLivedToken(email, token);
    },
    createLongLivedToken: (_, { token }) => {
      return createLongLivedToken(token);
    }
  },
  Person: {
    __resolveType: person => {
      if (person.admin) {
        return "Admin";
      }
      return "User";
    }
  },
  User: {
    pins({ id }) {
      return Object.values(database.pins).filter(
        pin => pin.user_id === id
      );
    }
  },
  SearchResult: {
    __resolveType: searchResult => {
      if (searchResult.admin) {
        return "Admin";
      }
      if (searchResult.email) {
        return "User";
      }
      return "Pin";
    }
  }
};

module.exports = resolvers;
```

В этом случае не все поля `Query` и `Mutation` имеют соответствующий резолвер. Если у поля нет резовлера, оно будет иметь значение `null`. Конечно, это только для демонстрационных целей. Ваши клиенты API не будут очень довольны запросами, которые всегда возвращают неопределённое значение.

Можно заметить, что большая часть логики в полях `Query` и `Mutations` состоит из функций, определенных в файле `business-logic.js`. Содержимое функций — чаще всего доступ к данным и вызовы методов из модуля бизнес-логики.

Некоторые из типов в файле `resolvers.js` имеют методы `__resolveType`. Это метод, который использует `makeExecutableSchema` из `graphql-tools`. Он определяет тип объектов типа, которые имеют `Union` или `Interface`.

Вы можете попробовать схему этого примера, если откроете консоль склонированного примера и запустив в ней `node queries.js`. Этот скрипт имитирует пользователя, который сначала создает токен аутентификации и отправляет его, чтобы можно добавить новый пин.

```bash
$ node queries
API Token:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
{
  "data": {
    "addPin": {
      "id": "f5220ee1-bfeb-48a0-be9f-c63d055b8139",
      "title": "Hello world",
      "link": "http://graphql.college/fullstack-graphql",
      "image": "http://graphql.college/fullstack-graphql",
      "user_id": "75c16079-b3ef-43f0-a352-ae03f2488baa"
    }
  }
}
```

Не бойтесь экспериментировать, изменяя различные резолвер-функции и наблюдая за тем, как изменяется конечный результат. Вы также можете создавать различные запросы, теперь, когда вы уже знаете, какие запросы и мутации предоставляет ваша схема.

## 2.5 Резюме

Вы узнали, как создавать GraphQL-схемы. Вы написали определения типов с использованием SDL, а также резолверы, используя Javascript. Схема, созданная в рамках этой главы, доступна скриптами, использующими `graphql-js`.

В следующей главе вы узнаете, как создавать HTTP API с помощью GraphQL. Вы добавите различные слои, составляющие сервер GraphQL, поверх схемы GraphQL. Этот API будет иметь несколько дополнительных уровней, включая HTTP, базу данных и аутентификацию.

