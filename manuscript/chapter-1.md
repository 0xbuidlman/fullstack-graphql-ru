# 1. Чтение и запись

В этой главе вы узнаете, как использовать GraphQL с точки зрения разработчика. Объясняется, как использовать запросы[^queries_note] и мутации для чтения и записи данных сервера GraphQL.

![Запросы и мутации](images/graphql-schema.png)

По мере изучения возможностей GraphQL, вы поймете, что это та технология, которая делает жизнь намного проще для фронтенд-разработчиков. GraphQL предоставляет полный контроль над данными, которые можно получить с сервера.

Сделать жизнь проще для клиента — это одна из главных задач создателей GraphQL. Результат эволюции языка демонстрирует следующий доклад: [Client-Driven Development](https://youtu.be/vQkGO5q52uE).

## 1.1 Запросы и мутации

В самом простом виде GraphQL предоставляет возможность запрашивать набор полей (fields).

Сам язык GraphQL определяет, как именно взаимодействовать с сервером. Запросы, в эталонном их виде, служат для получения данных, в то время как мутации требуются для того, чтобы эти данные записывать. Запросы служат той же цели, что и GET-запросам в старом добром REST, а мутации аналогичны методам POST, PUT, PATCH и DELETE.

В этой главе вы узнаете о следующих возможностях синтаксиса GraphQL:

* Простой запрос
* Запрос вложенных полей
* Запрос нескольких полей
* Наименование операции
* Аргументы
* Псевдонимы
* Фрагменты
* Переменные
* Директивы
* Переменные по умолчанию
* Мутации
* Встроенные фрагменты
* Метаинформация

Все концепции, о которых вы узнаете, имеют примеры, реализованные с помощью [`graphql-js`](https://github.com/graphql/graphql-js). GraphQL JS — эталонная реализация GraphQL, написанная на JavaScript. Сама библиотека предоставляет функцию `graphql, позволяющая передать запрос в схему GraphQL.

Примеры в этой главе уже содержат базовую реализацию схемы GraphQL. Не волнуйтесь, если вы еще не понимаете, как всё это работает. В этой главе мы сосредоточимся на самих GraphQL-запросах, в то время как следующая будет посвящена созданию схемы. Обратите внимание, что приведённая схема содержит очень простую реализацию, поэтому не ожидайте большего, кроме случайных чисел или классический «Hello world» в качестве ответов сервера. Следующая глава научит вас правильно проектировать эту схему.

Несмотря на то, что GraphQL предназначен для использования HTTP-клиентами и работает с HTTP-сервером, выполнение запросов с использованием JavaScript-консоли поможет понять основы языка без каких-либо накладных расходов, т.е. без настройки сервера и прочего.

Му воспользуемся функцией `graphql`, которая экспортируется из `graphql-js`. В простейшем виде она принимает два аргумента и возвращает объект Promise. Первый аргумент — это объект схемы GraphQL. Второй аргумент — это строка, содержащая запрос GraphQL. Все примеры в этой главе расскажут вам, как написать этот запрос. Если же вы хотите узнать чуть больше, то всегда можно воспользоваться [документацией по API `graphql-js`](http://graphql.org/graphql-js/graphql/#graphql).

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = ``;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Воспользуйтесь [копированием этого примера в сервис Glitch](https://glitch.com/edit/#!/remix/pinapp-queries-mutations), чтобы получить возможность сразу же запустить и посмотреть в действии код, показанный в этой главе. Это даст вам полную свободу над проектом. Вы можете модифицировать его по своему усмотрению, запускать скрипты с помощью консоли и даже экспортировать его в GitHub.

После копирования этого проекта вы можете запустить любой из скриптов в папке `queries`. Далее откройте консоль, нажав «Logs», а затем «Console», и выполните `node query/1-query.js` для просмотра выходных данных первого скрипта.

Теперь у вас есть все необходимое, чтобы начать изучение синтаксиса GraphQL. Давайте уже приступим к отправке основных запросов.

## 1.2 Запрос

Как мы уже говорили в начале этой главы, GraphQL предоставляет возможность запрашивать конкретные поля объектов. Запрос определяет, какие именно поля будет иметь ответ GraphQL в формате JSON[^chapter1-json]. Синтаксис языка запросов очень похож на формат объектов в JSON с перечислением ключей без их значений. Например, если вы хотите получить список пользователей, каждый из которых имеет поле электронной почты, вы можете написать следующий запрос:

[^chapter1-json]: GraphQL не накладывает никаких ограничений на формат ответов сервера, однако JSON является самым популярным и довольно читаемым вариантом.

```graphql
{
  users {
    email
  }
}
```

Вы можете передать этот запрос вместе со схемой в функцию `graphql`. Помните, что именно второй аргумент, передаваемый в функцию `graphql`, является строкой запроса. Давайте посмотрим пример скрипта.

`queries/1-query.js`

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  {
    users {
      email
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Запуск приведённого выше кода в консоли вернёт ответ с корневым ключом `"data"`, в котором есть все запрошенные в запросе поля. Внутри поля `"data"` вы увидите структуру, которая точно соответствует отправленному запросу: вы увидите ключ `"users"`, который в свою очередь содержит массив объектов с ключом `"email"`.

```bash
$ node queries/1-query.js
{
 "data": {
  "users": [
   {
    "email": "Hello World"
   },
   {
    "email": "Hello World"
   }
  ]
 }
}
```

## 1.3 Вложенные поля

Используя GraphQL можно запросить вложенные поля. Одно из больших преимуществ GraphQL по сравнению с REST — это выборка вложенных ресурсов в одном запросе. Вы можете запросить ресурс, например пользователей, а также список вложенных ресурсов, например, пинов[^pins], в одном запросе. Чтобы сделать это с помощью REST, вам потребуется запрашивать пользователей и пины в отдельных HTTP-запросах.

[^pins]: Под _пином_, как правило, подразумевается изображение, у которого необязательно может быть название, описание, ссылка (источник изображения). Название пришло из сервиса Pinterest, в котором пользователь может создавать пины. 

Обратите внимание, что только поля с типом `Object` могут иметь вложенные поля. Вы не можете запрашивать вложенные поля из других типов, таких как `String`, `Int` и др.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  {
    users {
      email
      pins {
        title
      }
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Приведенный выше пример показывает, насколько легко получить вложенные ресурсы. Как вы понимаете, выполнение предыдущего примера вернет JSON-объект с точно такими же ключами, которые были указаны в запросе. Убедитесь в этом сами, запустив команду `node query/2-fields.js` в консоли из-под директории проекта.

```bash
$ node queries/2-fields.js
{
 "data": {
  "users": [
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   },
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   }
  ]
 }
}
```

## 1.4 Несколько полей

GraphQL позволяет получить несколько полей в одном запросе. В предыдущем примере вы видели, что можно запросить вложенные ресурсы, но также возможно запросить совершенно не связанные с друг другом ресурсы в одной и той же операции.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  {
    users {
      email
    }
    pins {
      title
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Теперь вы понимаете, что GraphQL-запросы на самом деле представляют из себя получение конкретных полей объектов. Если вы выполните `node queries/3-multiple-fields.js`, то получите объект с двумя ключами: `users` и `pins`.

```bash
$ node queries/3-multiple-fields.js
{
 "data": {
  "users": [
   {
    "email": "Hello World"
   },
   {
    "email": "Hello World"
   }
  ],
  "pins": [
   {
    "title": "Hello World"
   },
   {
    "title": "Hello World"
   }
  ]
 }
}
```

## 1.5 Название операции

До сих пор мы использовали сокращенный синтаксис запросов GraphQL, хотя вместе с ним есть более длинный синтаксис, который предоставляет больше возможностей. Более длинный синтаксис включает ключевое слово `query` и имя операции. Неоднократно, если не всегда, вы будете использовать именно такой синтаксис, поскольку он позволяет указывать переменные или использовать различные операции, такие как мутации или подписки, которые мы рассмотрим в оставшейся части книги.

Вот как выглядит запрос с именем операции `GetUsers`:

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query GetUsers {
    users {
      email
      pins {
        title
      }
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Вы можете запустить предыдущий запрос, набрав в консоли `node queries/4-operation-name.js`. Обратите внимание, что приведенная выше версия запроса работает аналогично, как и сокращенная версия.

```bash
$ node queries/4-operation-name.js
{
 "data": {
  "users": [
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   },
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   }
  ]
 }
}
```

## 1.6 Аргументы

У всех полей могут быть аргументы, которые можно использовать аналогично, как и аргументы функции. Вы можете рассматривать GraphQL-поля как функции, а не свойства. Представление их в виде функций дает более четкое представление о том, что вы можете сделать с полями, передав им аргументы.

Давайте предположим, например, что вы хотите запросить пин по идентификатору, запросив поле `pinById`. Можно получить пин с идентификатором `1`, передав в запрос соответствующий именованный аргумент подобным образом:

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query {
    pinById(id: "1") {
      title
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Выполнение `node queries/5-arguments.js` в консоли приведёт к следующему выводу:

```bash
$ node queries/5-arguments.js
{
 "data": {
  "pinById": {
   "title": "Hello World"
  }
 }
}
```

## 1.7 Псевдонимы

Что произойдет, если вы захотите запросить одно и то же поле дважды в одном запросе? Ну... вы можете достичь этого с помощью псевдонимов. Псевдонимы позволяют связать имя с полем, так что в ответе будет указан псевдоним вместо имя ключа.

Псевдоним поля — это также просто, как и добавление имени поля с желаемым псевдонимом и двоеточием (:).

Псевдонимы особенно полезны при запросе одного и того же поля, но с разными аргументами. Следующий запрос дважды запрашивает поле `pinById`, используя псевдонимы: первое поле будет иметь псевдоним `firstPin`, а второе поле — `secondPin`.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query {
    firstPin: pinById(id: "1") {
      title
    }
    secondPin: pinById(id: "2") {
      title
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Как вы видите, ответ содержит псевдонимы вместо имени поля. Проверьте сами, выполнив команду `node queries/6-aliases.js`.

```bash
$ node queries/6-aliases.js
{
 "data": {
  "firstPin": {
   "title": "Hello World"
  },
  "secondPin": {
   "title": "Hello World"
  }
 }
}
```

## 1.8 Фрагменты

Синтаксис GraphQL предоставляет возможность многократного использования набора полей с использованием ключевого поля `fragment`. Это язык, предназначенный для запросов полей, поэтому вполне естественно ожидать вариант для многократного использования полей в разных частях запроса.

Для повторного использования поля, сначала нужно определить фрагмент, а затем поместить фрагмент в разные части запроса.

Определите фрагменты, используя следующий синтаксис: `fragment [fragmentName] on [Type] { field anotherField }`. Используйте фрагменты, поместив `...[fragmentName]` в то место запроса, где вы указали бы поле.

Любой примере лучше всего продемонстрирует какую-либо возможность. В следующем примере определяется фрагмент с именем `pinFields`, а затем используется дважды в запросе.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query {
    pins {
      ...pinFields
    }
    users {
      email
      pins {
        ...pinFields
      }
    }
  }
  fragment pinFields on Pin {
    title
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Выполните запрос выше с помощью команды `node queries/7-fragments.js`. Попробуйте поиграть с этим фрагментом, изменив список запрашиваемых полей, и посмотрите, как измениться вывод скрипта.

```bash
$ node queries/7-fragments.js
{
 "data": {
  "pins": [
   {
    "title": "Hello World"
   },
   {
    "title": "Hello World"
   }
  ],
  "users": [
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   },
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   }
  ]
 }
}
```

## 1.9 Переменные

Так же, как фрагменты позволяют вам повторно использовать наборы полей, переменные дают повторно использовать запросы. Используя переменные, можно указать, какие части запроса являются настраиваемыми, так что вы можете использовать запрос несколько раз, изменяя значения переменных. Используя переменные, можно создавать динамические запросы.

Давайте посмотрим, как вы можете добавить переменные в пример запроса пинов по идентификатору. Можно определить переменную с именем `$id`, указать ее тип `String` и пометить ее как обязательную, поставив восклицательный знак (`!`) после названия типа.

Следующий фрагмент определяет переменную `$id` в своем запросе и отправляет ее вместе со схемой и списком переменных в `graphql`. Функция `graphql` получает список переменных в качестве пятого аргумента.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query ($id: String!) {
    pinById(id: $id) {
      title
    }
  }
`;

graphql(schema, query, undefined, undefined, {
  id: "1"
}).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Результат выполнения `node query / 8-variables.js` довольно ясен.

```bash
$ node queries/8-variables.js
{
 "data": {
  "pinById": {
   "title": "Hello World"
  }
 }
}
```

## 1.10 Директивы

По аналогии как переменные дают возможность создавать динамические запросы путем изменения аргументов, директивы позволяют конструировать динамические запросы, которые изменяют структуру и форму их результата.

Директивы возможно прикрепить к полям или фрагментам. Все директивы начинаются с символа `@`.

GraphQL-серверы могут предоставлять любое количество директив, которое они пожелают, однако в спецификации GraphQL определены две обязательные директивы: `@include(if: Boolean)` и `@skip(if: Boolean)`. Первая директива включает поле только если `if` равно true, а вторая, напротив, пропускает поле, когда `if` равно true.

Следующий пример показывает директивы в действии. Директива `@include` помещается в поле `pins` и параметризует значение, используя переменную с именем `$withPins`.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query ($withPins: Boolean!) {
    users {
      email
      pins @include(if: $withPins) {
        title
      }
    }
  }
`;

graphql(schema, query, undefined, undefined, {
  withPins: true
}).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Двигайтесь дальше, выполните предыдущий пример через команду `node queries/9-directives.js`. Измените `withPins` на false, что увидеть, как изменится структура результата.

```bash
$ node queries/9-directives.js
{
 "data": {
  "users": [
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   },
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   }
  ]
 }
}
```

## 1.11 Переменные по умолчанию

Синтаксис GraphQL даёт определять значения по умолчанию для переменных. Это возможно, если добавить знак равенства (=) после типа переменной.

Давайте рассмотрим пример, добавив параметр по умолчанию `true` к предыдущему примеру с директивами. Значение по умолчанию для переменной позволяет вызвать функцию `graphql` в примере, не указывая значение для `withPins` в аргументе списка переменных.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query ($withPins: Boolean = true) {
    users {
      email
      pins @include(if: $withPins) {
        title
      }
    }
  }
`;

graphql(schema, query).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Выполните в консоли: `node queries/10-default-variables.js`. Обратите внимание, вывод выглядит точно так же, как и вызов `graphql` со значением `withPins`, равным `true`.

```bash
$ node queries/10-default-variables.js
{
 "data": {
  "users": [
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   },
   {
    "email": "Hello World",
    "pins": [
     {
      "title": "Hello World"
     },
     {
      "title": "Hello World"
     }
    ]
   }
  ]
 }
}
```

## 1.12 Встроенные фрагменты

Встроенные фрагменты предусматривают способ указать список встроенных полей. В отличие от обычных фрагментов, которые должны быть определены с помощью ключевого слова `fragment`, встроенные фрагменты не нужно где-либо определять.

Эти типы фрагментов полезны при запросе полей с типом `Union` или `Interface`. Эти поля могут возвращать объекты с различными полями, в зависимости от типа объекта. Вы можете использовать фрагменты, чтобы указать, какие поля возвращать, основываясь на типе объекта.

Отличный случай использования встроенных фрагментов — поисковый запрос, который может возвращать объекты разных типов. В следующем фрагменте показано, как можно использовать встроенные фрагменты, чтобы получить разный набор полей из запроса `search`. Если возвращаемый объект — это `Person`, значит нужно вернуть его `email`, а если этот объект — `Pin`, то вернуть его `title`.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query ($text: String!) {
    search(text: $text) {
      ... on Person {
        email
      }
      ... on Pin {
        title
      }
    }
  }
`;

graphql(schema, query, undefined, undefined, {
  text: "Hello world"
}).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Запустите этот пример, используя `node queries/11-inline-fragments.js`.

```bash
$ node queries/11-inline-fragments.js
{
 "data": {
  "search": [
   {
    "title": "Hello World"
   },
   {
    "email": "Hello World"
   }
  ]
 }
}
```

## 1.13 Метаполя

Запросы могут запрашивать метаполя, представляющие собой специальные поля, которые содержат информацию о схеме.

GraphQL позволяет получать имена типов объектов, запрашивая метаполе с именем `__typename`.

Данное метаполе полезно в тех же ситуациях, где удобны встроенные фрагменты, то есть в запросах, которые могут возвращать несколько типов полей, таких как `Union` или `Interface`.

Следующий фрагмент кода добавляет поле `__typename` к примеру запроса `search` из объяснения встроенных фрагментов.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  query ($text: String!) {
    search(text: $text) {
      __typename
      ... on Person {
        email
      }
      ... on Pin {
        title
      }
    }
  }
`;

graphql(schema, query, undefined, undefined, {
  text: "Hello world"
}).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Запустите предыдущий скрипт, выполнив в командной строке `node queries/12-meta-fields.js`. Вы увидите, что ответ содержит поле `__typename` в каждом объекте.

```bash
$ node queries/12-meta-fields.js
{
 "data": {
  "search": [
   {
    "__typename": "Admin",
    "email": "Hello World"
   },
   {
    "__typename": "Pin",
    "title": "Hello World"
   }
  ]
 }
}
```

## 1.14 Мутации

Синтаксис GraphQL позволяет создавать данные с использованием ключевого слова `mutation`. Оно работает аналогично ключевому слову `query`. Поддерживаются переменные, поэтому возможно запросить конкретные поля в ответе, а также всё то, что мы разбирали ранее. В отличие от запросов, мутации не имеют сокращенных форм написания, так что, они всегда начинаются с ключевого слова `mutation`.

Даже если мутации означают изменения данных, это всего лишь соглашение. Нет никакой гарантии, что серверы будут изменять данные внутри мутаций. Точно так же нельзя утверждать наверняка, что запросы содержат только изменения данных. Это соглашение похоже на соглашения из REST, предписывающие GET-запросам не иметь побочных эффектов, либо рекомендуют использовать POST-запросы для создания ресурсов. Данное соглашение не соблюдается тем или иным образом, однако вам следует придерживаться его, чтобы не преподносить неожиданные сюрпризы пользователям вашего API.

Давайте посмотрим, как мутации работают на практике, отправив мутацию с именем `addPin`, представленную на примере схемы, которую мы использовали в этой главе.

Вы заметите, что написание мутаций действительно похоже на написание запросов. Единственное отличие заключается в разном ключевом слове и, конечно, то, это операция предполагает изменение данных.

```js
const { graphql } = require("graphql");

const schema = require("../schema");

const query = `
  mutation AddPin($pin: PinInput!) {
    addPin(pin: $pin) {
      id
      title
      link
      image
    }
  }
`;

graphql(schema, query, undefined, undefined, {
  pin: {
    title: "Hello world",
    link: "Hello world",
    image: "Hello world"
  }
}).then(result =>
  console.log(JSON.stringify(result, null, 1))
);
```

Запустите этот пример мутации, набрав в консоли команду `node queries/13-mutations.js`. Помните, что наша схема работает с фиктивными данными, она не имеет реальной реализации, поэтому не ожидайте каких-либо изменений данных, вызванных данной мутацией.

```bash
$ node queries/13-mutations.js
{
 "data": {
  "addPin": {
   "id": "Hello World",
   "title": "Hello World",
   "link": "Hello World",
   "image": "Hello World"
  }
 }
}
```

Если вы запросите список пинов после последней мутации, вы заметите, что выполненная последняя мутация не создала никаких данных. Это происходит потому, что запросы в этой главе выполняются на имитированной схеме.

## 1.15 Резюме

GraphQL упрощает фронтенд-разработку, предоставляя мощные возможности запросов. Это облегчает получение нескольких вложенных ресурсов в одном запросе. Извлечение минимального набора полей из ресурса также является встроенной возможностью.

В следующей главе, «Моделирование данных», вы с нуля разработаете схему, которую использовали в этой главе. По сравнению с используемой схемой текущей главы, в следующей главе будет использоваться база данных в оперативной памяти для хранения схемы, и у нее не будет фиктивных значений.


[^queries_note]: Термины **queries**, **mutations** и **subscriptions**, используемые в рамках этой книги, помимо основного значения являются и самостоятельными определениями, которые обозначают типы запросов на сервер: запросы, мутации и подписки, соответственно. — Здесь и далее прим. пер.